#include <iostream>
#include <iomanip>
#include <string>

#include <NVX/nvx.h>
#include <NVX/nvx_timer.hpp>
#include <NVX/SyncTimer.hpp>
#include <OVX/FrameSourceOVX.hpp>
#include <OVX/RenderOVX.hpp>
#include <OVX/UtilityOVX.hpp>


struct EventData {
    EventData(): showSource(true), stop(false), pause(false) {}

    bool showSource;
    bool stop;
    bool pause;
};


void keyboardEventCallback(void* eventData, vx_char key, vx_uint32 /*x*/, vx_uint32 /*y*/) {
    EventData* data = static_cast<EventData*>(eventData);

    if (key == 27) { // escape
        data->stop = true;
    }
    else if (key == 'm') {
        data->showSource = !data->showSource;
    }
    else if (key == 32) { // space
        data->pause = !data->pause;
    }
}


int main (int argc, char* argv[]){
    try{

        // Step 1: create application 
        nvxio::Application &app = nvxio::Application::get();
        ovxio::printVersionInfo();

        // Step 2: Check for input arguments and Parse them
        std::string inputFileName = app.findSampleFilePath("cars.mp4");
        std::cout << "Input File: " << inputFileName << std::endl;


        // Step 3: Initialize the application
        app.init(argc, argv);


        // Step 4: Create a Context
        vx_context context = vxCreateContext();
        if (vxGetStatus((vx_reference)context) != VX_SUCCESS) {
            printf("Failed to create OpenVX context!\n");
            return -1;
        }


        // Step 5: Set the logger
        // Messages generated by the OpenVX framework will be given
        // to ovxio::stdoutLogCallback
        vxRegisterLogCallback(context, &ovxio::stdoutLogCallback, vx_false_e);


        // Step 6: Read and check input parameters
        // Create a NVXIO-based frame source
        std::unique_ptr<ovxio::FrameSource> frameSource(
            ovxio::createDefaultFrameSource(context, inputFileName));

        if (!frameSource || !frameSource->open()) {
            std::cerr << "Error: Can't open source URI " << inputFileName << std::endl;
            return nvxio::Application::APP_EXIT_CODE_NO_RESOURCE;
        }

        ovxio::FrameSource::Parameters frameConfig = frameSource->getConfiguration();

        std::cout << "Frame Width: " << frameConfig.frameWidth << std::endl;
        std::cout << "Frame Height: " << frameConfig.frameHeight << std::endl;


        // Step 7: Create a NVXIO-based render
        std::unique_ptr<ovxio::Render> render(
            ovxio::createDefaultRender(context, "Color Conversion", frameConfig.frameWidth, frameConfig.frameHeight));
        
        if (!render){
            std::cerr << "Error: Cannot create render!" << std::endl;
            return nvxio::Application::APP_EXIT_CODE_NO_RENDER;
        } 


        // Step 8: Setup Keyboard events
        // The application recieves the keyboard events via the
        // keyboardEventCallback() function registered via the renderer object
        EventData eventData;
        render->setOnKeyboardEventCallback(keyboardEventCallback, &eventData);


        // Step 9: Create OpenVX objects
        // frame and edges vx_image objects are created to hold the frames from the video source
        vx_image rgbFrame = vxCreateImage(context, frameConfig.frameWidth, frameConfig.frameHeight, VX_DF_IMAGE_RGBX);
        NVXIO_CHECK_REFERENCE(rgbFrame);

        vx_image greyFrame = vxCreateImage(context, frameConfig.frameWidth, frameConfig.frameHeight, VX_DF_IMAGE_U8);
        NVXIO_CHECK_REFERENCE(greyFrame);
        

        // Step 10: vxCreateGraph() instantiates the pipeline
        vx_graph graph = vxCreateGraph(context);
        NVXIO_CHECK_REFERENCE(graph);


        // Setp 11: Color Conversion
        vx_node cvtNode = vxColorConvertNode(graph, rgbFrame, greyFrame);


        // Setp 12: Ensure highest graph optimization level
        const char* option = "-O3";
        NVXIO_SAFE_CALL( vxSetGraphAttribute(graph, NVX_GRAPH_VERIFY_OPTIONS, option, strlen(option)) );


        // Step 13: Verify the graph
        vx_status verify_status = vxVerifyGraph(graph);
        if (verify_status != VX_SUCCESS){
            std::cerr << "Error: Graph verification failed. See the NVX LOG for explanation." << std::endl;
            return nvxio::Application::APP_EXIT_CODE_INVALID_GRAPH;
        }


        // Step 14: Start Main Loop
        std::unique_ptr<nvxio::SyncTimer> syncTimer = nvxio::createSyncTimer();
        syncTimer->arm(1. / app.getFPSLimit());

        double proc_ms = 0;
        nvx::Timer totalTimer;
        totalTimer.tic();

        while(!eventData.stop){
            if (!eventData.pause){
                // fetch one by one frame 
                ovxio::FrameSource::FrameStatus frameStatus = frameSource->fetch(rgbFrame);

                if (frameStatus == ovxio::FrameSource::TIMEOUT)
                    continue;
                if (frameStatus == ovxio::FrameSource::CLOSED){
                    if (!frameSource->open()){
                        std::cerr << "Error: Failed to reopen the source" << std::endl;
                        break;
                    }
                    continue;
                }

                // Process
                nvx::Timer procTimer;
                procTimer.tic();
                NVXIO_SAFE_CALL(vxProcessGraph(graph));
                proc_ms = procTimer.toc();

                // Show performance statistics
                vx_perf_t perf;

                NVXIO_SAFE_CALL( vxQueryGraph(graph, VX_GRAPH_ATTRIBUTE_PERFORMANCE, &perf, sizeof(perf)));
                std::cout << "Graph Time : " << perf.tmp / 1000000.0 << " ms" << std::endl;
            }

            double total_ms = totalTimer.toc();
            std::cout << "Display Time : " << total_ms << " ms" << std::endl << std::endl;
            syncTimer->synchronize();
            total_ms = totalTimer.toc();
            totalTimer.tic();

            // Show original image 
            if (eventData.showSource){
                render->putImage(rgbFrame);
            }
            else{
                render->putImage(greyFrame);
            }

            // Display information and performance metrics
            std::ostringstream msg;
            msg << std::fixed << std::setprecision(1);

            msg << "Resolution: " << frameConfig.frameWidth << 'x' << frameConfig.frameHeight << std::endl;
            msg << "Algorithm: " << proc_ms << " ms / " << 1000.0 / proc_ms << " FPS" << std::endl;
            msg << "Display: " << total_ms  << " ms / " << 1000.0 / total_ms << " FPS" << std::endl;

            msg << std::setprecision(6);
            msg.unsetf(std::ios_base::floatfield);
            msg << "LIMITED TO " << app.getFPSLimit() << " FPS FOR DISPLAY" << std::endl;
            msg << "M - switch Source/Edges" << std::endl;
            msg << "Space - pause/resume" << std::endl;
            msg << "Esc - close the demo";

            ovxio::Render::TextBoxStyle testStyle = {
                {255u, 255u, 255u, 255u},  // color
                {0u,   0u,   0u,   127u},  // bgcolor
                {10u, 10u} // origin
            };

            render->putTextViewport(msg.str(), testStyle);

            // Flush all rendering commands
            if (!render->flush()){
                eventData.stop = true;
            }
        }
        
        // Step 15: Release Resources
        vxReleaseNode(&cvtNode);
        vxReleaseGraph(&graph);
        vxReleaseContext(&context);
        printf("Graph processing complete.\n");
    }
    catch (const std::exception &e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return nvxio::Application::APP_EXIT_CODE_ERROR;
    }

    return nvxio::Application::APP_EXIT_CODE_SUCCESS;
}