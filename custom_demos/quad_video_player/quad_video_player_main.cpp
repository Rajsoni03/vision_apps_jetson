
#include <cmath>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <memory>

#include <NVX/nvx.h>
#include <NVX/nvx_timer.hpp>

#include <NVX/Application.hpp>
#include <NVX/ConfigParser.hpp>
#include <OVX/FrameSourceOVX.hpp>
#include <OVX/RenderOVX.hpp>
#include <NVX/SyncTimer.hpp>
#include <OVX/UtilityOVX.hpp>


// Process events
struct EventData
{
    EventData(): showSource(true), stop(false), pause(false), sourceVideoNumber(0) {}

    bool showSource;
    bool stop;
    bool pause;
    uint8_t sourceVideoNumber;
};


void keyboardEventCallback(void* eventData, vx_char key, vx_uint32 /*x*/, vx_uint32 /*y*/)
{
    EventData* data = static_cast<EventData*>(eventData);

    if (key == 27)  // escape
        data->stop = true;
    else if (key == 32) // space
        data->pause = !data->pause;
    else if (key == 'm')
    {
        data->showSource = !data->showSource;
        data->sourceVideoNumber = 1;
    }
    else if (key == '1')
        data->sourceVideoNumber = 1;
    else if (key == '2')
        data->sourceVideoNumber = 2;
    else if (key == '3')
        data->sourceVideoNumber = 3;
    else if (key == '4')
        data->sourceVideoNumber = 4;
}

// main - Application entry point
int main(int argc, char** argv)
{
    try
    {
        nvxio::Application &app = nvxio::Application::get();
        ovxio::printVersionInfo();

        // Take video inputs
        std::string sourceUri1 = app.findSampleFilePath("cars.mp4");
        std::string sourceUri2 = app.findSampleFilePath("signs.avi");
        std::string sourceUri3 = app.findSampleFilePath("signs.avi");
        std::string sourceUri4 = app.findSampleFilePath("cars.mp4");

        // Take video inputs with full path 
        // std::string sourceUri1 = "/media/raj/HP/data/cars.mp4";
        // std::string sourceUri2 = "/media/raj/HP/data/signs.avi";
        // std::string sourceUri3 = "/media/raj/HP/data/signs.avi";
        // std::string sourceUri4 = "/media/raj/HP/data/cars.mp4";

        app.init(argc, argv);

        // NVXIO-based renderer object and frame source are instantiated
        // and attached to the OpenVX context object. NVXIO ContextGuard
        // object is used to automatically manage the OpenVX context
        // creation and destruction.
        ovxio::ContextGuard context;
        vxDirective(context, VX_DIRECTIVE_ENABLE_PERFORMANCE);

        // Messages generated by the OpenVX framework will be given
        // to ovxio::stdoutLogCallback
        vxRegisterLogCallback(context, &ovxio::stdoutLogCallback, vx_false_e);

        // Create a NVXIO-based frame source
        std::unique_ptr<ovxio::FrameSource> frameSource1(
            ovxio::createDefaultFrameSource(context, sourceUri1));
        std::unique_ptr<ovxio::FrameSource> frameSource2(
            ovxio::createDefaultFrameSource(context, sourceUri2));
        std::unique_ptr<ovxio::FrameSource> frameSource3(
            ovxio::createDefaultFrameSource(context, sourceUri3));
        std::unique_ptr<ovxio::FrameSource> frameSource4(
            ovxio::createDefaultFrameSource(context, sourceUri4));

        if (!frameSource1 || !frameSource1->open() ||
            !frameSource2 || !frameSource2->open() ||
            !frameSource3 || !frameSource3->open() ||
            !frameSource4 || !frameSource4->open())
        {
            std::cerr << "Error: Can't open source URI" << std::endl;
            return nvxio::Application::APP_EXIT_CODE_NO_RESOURCE;
        }

        ovxio::FrameSource::Parameters frameConfig1 = frameSource1->getConfiguration();
        ovxio::FrameSource::Parameters frameConfig2 = frameSource2->getConfiguration();
        ovxio::FrameSource::Parameters frameConfig3 = frameSource3->getConfiguration();
        ovxio::FrameSource::Parameters frameConfig4 = frameSource4->getConfiguration();

        // Create a NVXIO-based render
        std::unique_ptr<ovxio::Render> render(
            ovxio::createDefaultRender(context, "Quad Cam Demo", frameConfig1.frameWidth * 2, frameConfig1.frameHeight * 2));
        if (!render){
            std::cerr << "Error: Cannot create render!" << std::endl;
            return nvxio::Application::APP_EXIT_CODE_NO_RENDER;
        }

        // The application recieves the keyboard events via the
        // keyboardEventCallback() function registered via the renderer object
        EventData eventData;
        render->setOnKeyboardEventCallback(keyboardEventCallback, &eventData);

        // Create OpenVX objects
        vx_image demoImg = vxCreateImage(context, 2 * frameConfig1.frameWidth, 2 * frameConfig1.frameHeight, VX_DF_IMAGE_RGBX);
        NVXIO_CHECK_REFERENCE(demoImg);   
        
        // create rectangle
        vx_rectangle_t topLetfRect; // (0,0) (1,1)
        topLetfRect.start_x = 0;
        topLetfRect.start_y = 0;
        topLetfRect.end_x = frameConfig1.frameWidth;
        topLetfRect.end_y = frameConfig1.frameHeight;

        vx_rectangle_t topRightRect; // (1,0) (2,1)
        topRightRect.start_x = topLetfRect.end_x;
        topRightRect.start_y = topLetfRect.start_y;
        topRightRect.end_x = 2 * topLetfRect.end_x;
        topRightRect.end_y = topLetfRect.end_y;

        vx_rectangle_t bottomLetfRect; // (0,1) (1,2)
        bottomLetfRect.start_x = topLetfRect.start_x;
        bottomLetfRect.start_y = topLetfRect.end_y;
        bottomLetfRect.end_x = topLetfRect.end_x;
        bottomLetfRect.end_y = 2 * topLetfRect.end_y;

        vx_rectangle_t bottonRightRect; // (1, 1) (2, 2)
        bottonRightRect.start_x = topLetfRect.end_x;
        bottonRightRect.start_y = topLetfRect.end_y;
        bottonRightRect.end_x = 2 * topLetfRect.end_x;
        bottonRightRect.end_y = 2 * topLetfRect.end_y;

        vx_image topLetfRoi = vxCreateImageFromROI(demoImg, &topLetfRect);
        NVXIO_CHECK_REFERENCE(topLetfRoi);
        vx_image topRightRoi = vxCreateImageFromROI(demoImg, &topRightRect);
        NVXIO_CHECK_REFERENCE(topRightRoi);
        vx_image bottomLetfRoi = vxCreateImageFromROI(demoImg, &bottomLetfRect);
        NVXIO_CHECK_REFERENCE(bottomLetfRoi);
        vx_image bottonRightRoi = vxCreateImageFromROI(demoImg, &bottonRightRect);
        NVXIO_CHECK_REFERENCE(bottonRightRoi);


        // Main loop
        std::unique_ptr<nvxio::SyncTimer> syncTimer = nvxio::createSyncTimer();
        syncTimer->arm(1. / app.getFPSLimit());

        double proc_ms = 0, total_ms = 0;
        nvx::Timer totalTimer;
        nvx::Timer procTimer;
        totalTimer.tic();


        while (!eventData.stop)
        {
            procTimer.tic();
            if (!eventData.pause)
            {
                ovxio::FrameSource::FrameStatus frameStatus1 = frameSource1->fetch(topLetfRoi);
                ovxio::FrameSource::FrameStatus frameStatus2 = frameSource2->fetch(topRightRoi);
                ovxio::FrameSource::FrameStatus frameStatus3 = frameSource3->fetch(bottomLetfRoi);
                ovxio::FrameSource::FrameStatus frameStatus4 = frameSource4->fetch(bottonRightRoi);

                if (frameStatus1 == ovxio::FrameSource::TIMEOUT) continue;
                if (frameStatus2 == ovxio::FrameSource::TIMEOUT) continue;
                if (frameStatus3 == ovxio::FrameSource::TIMEOUT) continue;
                if (frameStatus4 == ovxio::FrameSource::TIMEOUT) continue;

                if (frameStatus1 == ovxio::FrameSource::CLOSED)
                {
                    if (!frameSource1->open()){
                        std::cerr << "Error: Failed to reopen the source" << std::endl;
                        break;
                    }
                    continue;
                }
                if (frameStatus2 == ovxio::FrameSource::CLOSED) {
                    if (!frameSource2->open()){
                        std::cerr << "Error: Failed to reopen the source" << std::endl;
                        break;
                    }
                    continue;
                }
                if (frameStatus3 == ovxio::FrameSource::CLOSED) {
                    if (!frameSource3->open()){
                        std::cerr << "Error: Failed to reopen the source" << std::endl;
                        break;
                    }
                    continue;
                }
                if (frameStatus4 == ovxio::FrameSource::CLOSED) {
                    if (!frameSource4->open()){
                        std::cerr << "Error: Failed to reopen the source" << std::endl;
                        break;
                    }
                    continue;
                }


            }
            // time capture
            proc_ms = procTimer.toc();
            syncTimer->synchronize();
            total_ms = totalTimer.toc();
            totalTimer.tic();

            // Show original image or detected edges
            if (eventData.showSource)
            {
                render->putImage(demoImg);
            }
            else
            {
                if (eventData.sourceVideoNumber == 1)
                    render->putImage(topLetfRoi);
                else if (eventData.sourceVideoNumber == 2)
                    render->putImage(topRightRoi);
                else if (eventData.sourceVideoNumber == 3)
                    render->putImage(bottomLetfRoi);
                else if (eventData.sourceVideoNumber == 4)
                    render->putImage(bottonRightRoi);
            }

            // Display information and performance metrics
            std::ostringstream msg;
            msg << std::fixed << std::setprecision(1);

            msg << "Resolution: " << frameConfig1.frameWidth * 2 << 'x' << frameConfig1.frameHeight * 2 << std::endl;
            msg << "Algorithm: " << proc_ms << " ms / " << 1000.0 / proc_ms << " FPS" << std::endl;
            msg << "Display: " << total_ms  << " ms / " << 1000.0 / total_ms << " FPS" << std::endl;

            msg << std::setprecision(6);
            msg.unsetf(std::ios_base::floatfield);
            msg << "LIMITED TO " << app.getFPSLimit() << " FPS FOR DISPLAY" << std::endl;
            msg << "M - switch multi/single view" << std::endl;
            msg << "1|2|3|4 - switch input source" << std::endl;
            msg << "Space - pause/resume" << std::endl;
            msg << "Esc - close the demo";

            ovxio::Render::TextBoxStyle textStyle = {
                {255u, 255u, 255u, 255u}, // color
                {0u,   0u,   0u,   127u}, // bgcolor
                {10u, 10u} // origin
            };

            render->putTextViewport(msg.str(), textStyle);

            // Flush all rendering commands
            if (!render->flush())
            {
                eventData.stop = true;
            }
        }

        // Release all objects
        vxReleaseImage(&demoImg);
    }
    catch (const std::exception& e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
        return nvxio::Application::APP_EXIT_CODE_ERROR;
    }

    return nvxio::Application::APP_EXIT_CODE_SUCCESS;
}
